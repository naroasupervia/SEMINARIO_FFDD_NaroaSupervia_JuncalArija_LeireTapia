---
title: "Datos suicidio"
author: "Juncal Arija, Naroa Supervia, Leire Tapia"
date: "2025-11-06"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#**INTRODUCCIÓN**
contextualiza la idea del seminario, entrega una idea general de la temática, de lo que se sabe y sobre todo de lo que no se sabe y queréis abordar en vuestro trabajo.



#**OBJETIVOS** 
1. Describir la distribución del suicidio por sexo en España. 

2. Analizar las diferencias entre provincias. 

3. Estudiar la influencia del grupo de edad en la cantidad de suicidios. 

4. Unificar los datos CSV y JSON para obtener una vista más completa. 

5. (Opcional) Explorar si existe relación entre grupos de edad + provincias + sexo. 



#**PAQUETES UTILIZADOS**
Para poder utilizar nuestros conjuntos de datos es necesario importar las siguientes librerias y paquetes:

```{r , eval = TRUE,message=FALSE, warning=FALSE}
# Datos con formato .csv:
library(readr)

#Datos con formato .json:
library(tidyverse)
library(rjson)
library(tidyjson)

#Visualizacion resultados:
library(DT)
library(ggplot2)
library(gifski)
library(gganimate)
library(plotly)
library(dplyr)
library(mapSpain)

```



# **DESARROLLO Y RESULTADOS**
Una vez cargadas las librerias importamos los datos

## OBTENCIÓN DE LOS DATOS 
Explicar de donde vienen los datos 

## IMPORTACIÓN DE LOS DATOS

### **IMPORTACIÓN DATOS CSV**
En algunos de nuestros archivos csv, es necesario especificar el tipo de codificación que tienen, para que R pueda leer correctamente los caracteres especiales como *tildes* o *ñ*. En nuestro caso utilizan la codificacion *ISO 8859-1* que corresponde con el alfabeto español??? :

```{r , eval = TRUE,message=FALSE}

# Para conocer el tipo de codificación: 
encoding <- guess_encoding("INPUT/DATA/provincias_sexo.csv")
print(encoding)

```

```{r , eval = TRUE,message=FALSE}

provincias <- read_delim("INPUT/DATA/provincias_sexo.csv", 
                        delim = ";", trim_ws = TRUE, 
                        locale = locale(encoding = "ISO-8859-1"))
head(provincias)
```
### IMPORTACIÓN DEL JSON


```{r , eval = TRUE,message=FALSE}

library(jsonlite)

# Ruta al archivo JSON
ruta_json <- "INPUT/DATA/Suicidio_Edad-Sexo.json"

# Importar JSON y convertir a dataframe
suicidios_json <- fromJSON(ruta_json)
#suicidios_json <- as.data.frame(suicidios_json)

# Mostrar las primeras filas
head(suicidios_json)

```

## FILTRADO Y PREPARACIÓN DE LOS DATOS


### cambiamos el separador decimal
En el archivo csv tenemos una columna total con valores numericos usando la coma como separador decimal, esta coma debe convertirse en punto ya que R usa el punto "." como separador decimal:

```{r , eval = TRUE,message=FALSE}
provincias <- provincias %>%
  mutate(Total = as.numeric(gsub(",", ".", Total)))
```


### Normalizar nombres de provincias 
```{r , eval = TRUE,message=FALSE}
# Crear el dataframe filtrado para el gráfico
# (Usa el dataframe 'provincias' que ya cargaste y mutaste)
Suicidios_CSV_filtrado <- provincias %>%
  filter(Sexo != "Total", 
         Provincias != "Nacional")

# Ver el resultado (opcional)
head(Suicidios_CSV_filtrado)
```

### Eliminar "total" en sexo
Para así comparar hombres vs mujeres 
(entonces yo quitaría lo de cambiar el separador decimal xq si quitamos el total no nos hace falta camibar lo de . por , nose)


### El JSON:separar edad y sexo
Extraer:
- Lista de edades
- Lista de sexos
- Valor 
```{r , eval = TRUE,message=FALSE}
# Chunk CORREGIDO para: ### El JSON:separar edad y sexo
# (Asegúrate de tener 'library(tidyverse)' y 'library(jsonlite)' en tu chunk de paquetes)

# Este código usa un método más robusto para "aplanar" el JSON
# y evitar que se creen valores NA.

Suicidios_Edad <- as_tibble(suicidios_json) %>%
  
  # 1. Extraer el 'Valor' de la sub-lista 'Data'
  #    (map_dbl toma cada elemento de 'Data' y extrae el primer 'Valor')
  mutate(Valor = map_dbl(Data, ~ .x$Valor[1])) %>%
  
  # 2. Guardar el 'Nombre' original (ej. "De 15 a 29 años, Hombres")
  #    como un ID único para agrupar las filas.
  select(ID_Fila = Nombre, Valor, MetaData) %>%
  
  # 3. Desanidar 'MetaData', que creará dos filas por cada ID_Fila
  #    (una para 'edad' y otra para 'sexo')
  unnest(MetaData) %>%
  
  # 4. Seleccionar solo las columnas que necesitamos para pivotar
  select(ID_Fila, Valor, T3_Variable, Nombre) %>%

  # 5. Pivotar usando el ID_Fila. Esto asegura que la 'edad' y el 'sexo'
  #    del mismo ID_Fila terminen en la misma fila, junto a su 'Valor'.
  pivot_wider(names_from = T3_Variable, values_from = Nombre) %>%
  
  # 6. Filtrar los totales (como antes)
  filter(sexo != "Ambos sexos",
         edad != "Todas las edades") %>%
  
  # 7. (Opcional) Quitar la columna de ID, ya no la necesitamos
  select(edad, sexo, Valor)

# Ver el resultado (opcional)
# Esta tabla ya no debería tener NAs en 'edad' o 'sexo'
print("Datos JSON (versión final) listos:")
head(Suicidios_Edad)
```

## RESULTADOS 
Aquí vienen los gráficos 

### Suicidio por sexo a nivel nacional


### Suicidio por provincia
```{r , eval = TRUE,message=FALSE}
# Carga la librería plotly (si no está ya cargada)
library(plotly)

# 1. CREA el gráfico de ggplot (como antes, pero lo guardamos en una variable 'p')
#    (Añado 'ncol=6' para que plotly tenga un layout inicial ordenado)
p <- ggplot(Suicidios_CSV_filtrado, aes(x = Sexo, y = Total, color = Sexo)) + 
  geom_point() + 
  facet_wrap(~Provincias, ncol = 6) + # 6 columnas de mini-gráficos
  theme(
    axis.text.x = element_text(angle = 0), 
    strip.text = element_text(size = 7) 
  )

# 2. CONVIÉRTELO en interactivo con un solo comando
#    Ahora podrás hacer zoom y ver los detalles
ggplotly(p)
```
### Suicidio por edad (JSON)
```{r , eval = TRUE,message=FALSE}
# Gráfico 4.4.3: Suicidio por edad (CORREGIDO)
# La corrección está en aes(fill = sexo) -> (todo en minúscula)

ggplot(Suicidios_Edad, aes(x = edad, y = Valor, fill = sexo)) + 
  geom_bar(stat = "identity", position = "dodge") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```
### Union CSV + JSON 


....
Esto me lo dijo chat (puede ser para el 4.4 nose) -->
Como ambos archivos (csv y json) comparten la varaible sexo, podemos unirlos por dicha variable
```{r , eval = TRUE,message=FALSE}
merged <- provincias %>%
  group_by(Sexo) %>%
  summarise(Media_Provincial = mean(Total, na.rm = TRUE)) %>%
  left_join(edades, by = "Sexo")
```

# CONCLUSIONES



#REFERENCIAS 
